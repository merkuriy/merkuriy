# Цикл событий

Темы: Concurrency model, Параллельная модель, Event loop, Цикл событий, Событийный цикл, микрозадачи и макрозадачи

## Многопоточность в JS, 

JS по умолчанию однопоточен.

Асинхронность или параллелизм выполнения подзадач основывается на модели "событийного цикла".

Настоящие множественные потоки создаются с помощью Web Workers.

Каждый Web Worker и каждое окно/вкладка браузера (window) имеют свои потоки и соответственно собственные событийные циклы.

Исключение: все окна с одного домена (по правилу same origin) делят между собой один и тот же событийный цикл, ведь они могут синхронно коммуницировать между собой. (01)

Микрозадача — микротаск, microtask.

Макрозадача — макротаск, macrotask, полная задача.


## Цикл событий (Event loop)

Упрощённая схема cобытийного цикла:

1. Если в очереди маркозадач есть задача или несколько задач, то #2. Иначе будет режим ожидания задач (браузер не загружен).
2. Выполнить цикл макрозадач
    - 2.1. Выполнить одну макрозадачу
    - 2.2. Выполнить цикл микрозадач (все имеющиесч микрозадачи поочерёдно)    
    - 2.3. Перейти к #2.1
3. Здесь браузер может выполнить рендер и другие свои важные операции.
4. перейти к #1.

События (задачи) добавляются в очередь в любой момент, даже когда браузер загружен выполнением задач. События не добавляются, если у них нет обработчика.


#### Справочники и статьи

- https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop
- https://learn.javascript.ru/event-loop


#### Видео

[Про цикл событий в JavaScript или "как на самом деле работает асинхронность"?](https://www.youtube.com/watch?v=8cV4ZvHXQL4)


## Web Workers

Создание фоновых потоков из основного главного потока JS
https://developer.mozilla.org/ru/docs/DOM/Using_web_workers


## Promise

then, cath, finally — планируют выполнение переданной функции как микрозадача.

## setImmediate, setTimeout, setInterval

setImmediate без задержки (без отсрочки, неотложно) планирует выполнение переданной функции как макрозадача.
https://learn.javascript.ru/setimmediate

setTimeout ждёт заданной отсрочки и затем планирует новую макрозадачу для своего колбека. Вторым аргументом задаётся минимальное время, через которое будет запланировано событие постановки макрозадачи в очередь.


## Демонстрация

```js
let tasks = [1,2,3,4,5,6,7,8,9,10];

asyncMacrotaskForEach(tasks, delayForTaks);
asyncMicrotaskForEach(tasks, delayForTaks);

function delayForTaks (i) {
  let date = +new Date + 2000;
  while(new Date < date); // задержка времени в 2 сек
  console.log(i);
};

// как только запустите этот код попытайтесь выделить текст на странице,
// выделение будет отображаться каждые 2 сек(задержка в функции delayForTaks)
function asyncMacrotaskForEach(array, fc) {
  array.forEach(i => {
    setTimeout(fc, 0, 'macrotask ' + i);
    console.log('add macrotask');
  });
}

// как только запустите этот код попытайтесь выделить текст на странице,
// выделение будет отображаться только спустя 20 сек (10 микрозадач с задержками по 2 сек)
function asyncMicrotaskForEach(array, fc) {
  array.forEach(i => {
    Promise.resolve().then(() => fc('microtask ' + i));
    console.log('add microtask');
  })
}
```
